// Условие задачи
// В проектах программисты сталкиваются с необходимостью разделять логику, 
// которая должна функционировать независимо от обстоятельств, и такую, 
// которая должна быть активирована только после авторизации пользователя. 
// Точный момент авторизации непредсказуем, но как только она произойдёт, 
// соответствующая логика будет выполнена. Это принцип асинхронных вызовов 
// или асинхронного программирования.

// Давайте представим, что у нас есть функция, 
// которая по какому-то событию запустит нашу отложенную функциональность. 
// В качестве имитации такой задержки воспользуемся стандартной 
// функцией-таймером setTimeout.

// Как реализовать такую функцию, чтобы она отложенно выполнила функцию, 
// которая в неё передана?


const auth = function (cb) {
    /*
     * Необходимо реализовать функциональность, которая
     * позволит отложить выполнение переданной функции на определённое время.
     * Это позволит имитировать событие авторизации пользователя на веб-сайте, например.
     * В реальных условиях невозможно предсказать точный момент,
     * когда пользователь авторизуется на сайте или пройдёт авторизацию или нет. 
     * В свою очередь, остальная часть логики не сможет выполниться, 
     * пока не получит подтверждения об авторизации пользователя.
     * 
     * В момент вызова переданной функции cb в качестве параметров
     * необходимо передать объект { authorized: true }.
     */
    setTimeout(() => cb({ authorized: true }), 2000);
};


// Ожидаем что функции getUserProfile и getUserSettings начнут 
// свое исполнение через какое-то время

auth(subscribe);

function subscribe (data) {
  if (data && data.authorized) {
    getUserProfile();
    getUserSettings();
  }
};

function getUserProfile(count) {
  console.log("Получаем профиль пользователя");
}

function getUserSettings() {
  console.log("Получаем начтройки пользователя");
}

